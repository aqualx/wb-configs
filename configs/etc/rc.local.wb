#!/bin/bash
#
# rc.local
#
# This script is executed at the end of each multiuser runlevel.
# Make sure that the script will "exit 0" on success or any other
# value on error.
#
# In order to enable or disable this script just change the execution
# bits.
#
# By default this script does nothing.
set -e

# Wiren board

# Helper functions
die()
{
    local ret=$?
    >&2 echo "!!! $@"
    [[ $ret == 0 ]] && exit 1 || exit $ret
}

info()
{
    >&2 echo ">>> $@"
}

# some constants for convenience
STORAGE=/dev/mmcblk0
SECTOR_SIZE=512
MB=1024*1024
PART_START=0
TOTAL_SECTORS=0

# Generates single partition definition line for sfdisk.
# Increments PART_START variable to point to the start of the next partition
# (special case is Extended (5) fstype, which increments PART_START by 2048 sectors)
# Args:
# - size in megabytes (or '' to use all remaining space to the end)
# - filesystem type (looks like not really matters). when omitted, defaults to 83 (Linux)
wb_partition()
{
    [[ -z "$1" ]] &&
        local size=$[TOTAL_SECTORS-PART_START] ||
        local size=$[$1*MB/SECTOR_SIZE]
    local fstype=${2:-83}
    echo "$PART_START $size $fstype"
    [[ "$fstype" == 5 ]] && ((PART_START+=2048)) || ((PART_START+=$size))
}

# Creates all the needed partitions
wb_prepare_partitions()
{
    info "Preparing partitions"

    PART_START=$[4*MB/SECTOR_SIZE]
    TOTAL_SECTORS=$[`sfdisk -s $STORAGE`*2] ||
        die "Unable to get total sectors count for $STORAGE"

    sfdisk --no-reread --Linux --in-order -u S --dump > /tmp/partitions_backup
    dd if=/dev/zero of=$STORAGE bs=512 count=1
    {
        wb_partition 16 53    # uboot
        wb_partition 1024     # rootfs0
        wb_partition 1024     # rootfs1
        wb_partition '' 5     # <extended>
        wb_partition 256 82   # swap
        wb_partition ''       # data
    } | sfdisk --no-reread --Linux --in-order -u S $STORAGE || true
    # FIXME: sfdisk succesfully writes partition table, but returns error
    # because it can't reread partitions on mounted disk, so just bypass error
    # handling.
    #{
    #    info "Failed, sfdisk returned $?"
    #    info "Restoring old partition table"
    #    sfdisk --no-reread --Linux --in-order -u S $STORAGE < /tmp/partitions_backup
    #    rm -f /tmp/partitions_backup
    #    die "Prepare partitions failed"
    #}
    rm -f /tmp/partitions_backup

    info "Partition table changed, reboot needed"
    reboot
}

# Run mkfs.ext4 with custom options
# Args:
# - device file
# - label (optional)
wb_mkfs_ext4()
{
    local dev=$1
    local label=$2
    
    info "Formatting $dev ($label)"
    yes | mkfs.ext4 -E stride=2,stripe-width=1024 -b 4096 -L "$label" "$dev"
}

wb_prepare_filesystems()
{
    info "Resizing root filesystem"
    resize2fs ${STORAGE}p2

    wb_mkfs_ext4 ${STORAGE}p3 rootfs || die "Failed"
    wb_mkfs_ext4 ${STORAGE}p6 data || die "Failed"
    mount -a

    info "Creating swap"
    mkswap ${STORAGE}p5 || die "Failed"
    swapon -a

    info "Copying rootfs to redundant partition"
    local mnt_rootfs_src=`mktemp -d`
    local mnt_rootfs_dst=`mktemp -d`
    mount --bind / $mnt_rootfs_src
    mount ${STORAGE}p3 $mnt_rootfs_dst
    cp -a $mnt_rootfs_src/. $mnt_rootfs_dst
}

wb_move_to_data()
{
    [[ "$1" == "nosave" ]] && {
        local nosave=1
        shift
    }
    local src=$1
    local dst="/mnt/data${2:-$1}"

    if [[ -h "$src" ]]; then                  # is it a symlink already?
        if [[ -e "$src" ]]; then
            local f=`readlink -f "$src"`
            if [[ "$f" != "$dst" ]]; then
                [[ -z "$nosave" ]] && mv "$src" "${src}.default"
                mkdir -p `dirname "$dst"`
                cp -aH "$f" "$dst"
                rm -rf "$src"
                ln -Tfs "$dst" "$src"
                info "$src: copyed $f to $dst, replaced symlink"
            else
                info "$src: good symlink, not touching"
            fi
        else
            local f=''
            if [[ -e "$dst" ]]; then
                f=$dst
            elif [[ -e "${src}.default" ]]; then
                f="${src}.default"
            elif [[ -e "${src}.wb" ]]; then
                f="${src}.wb"
                [[ -z "$nosave" ]] && {
                    rm -rf "${src}.default"
                    ln -Tfs "$f" "${src}.default"
                }
            fi

            if [[ -n "$f" ]]; then
                mkdir -p `dirname "$dst"`
                [[ "$f" != "$dst" ]] && cp -aH "$f" "$dst"
                rm -rf "$src"
                ln -Tfs "$dst" "$src"
                info "$src: broken symlink, repaired using existing file $f"
            else
                info "$src: WARNING: broken symlink, and unable to repair"
            fi
        fi
    elif [[ -e "$src" ]]; then        # is it a regular file/dir?
        [[ -z "$nosave" ]] && cp -a "$src" "${src}.default" # save copy for possible future use
        if [[ -e "$dst" ]]; then      # is there already a file in /mnt/data?
            info "$src: replaced with symlink to existing $dst"
        else
            mkdir -p `dirname "$dst"`
            mv "$src" "$dst"
            info "$src: copyed to $dst, replaced with symlink"
        fi
        rm -rf "$src"
        ln -Tfs "$dst" "$src"
    else
        info "$src: WARNING: is neither symlink or regular file, don't touch"
    fi
}

wb_firstboot()
{
    [[ -e "/var/lib/wirenboard" ]] || mkdir /var/lib/wirenboard

    [[ -f "/var/lib/wirenboard/serial.conf" ]] || {
        info "Get WB serial number"
        wb-gen-serial > /var/lib/wirenboard/serial.conf || return 4
    }

    info "Regenerating SSH host keys"
    yes | ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N '' -t ecdsa || return 1
    yes | ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N '' -t dsa || return 2
    yes | ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N '' -t rsa || return 3

    info "Moving files to /mnt/data"
    # TODO: think what other important files to move
    wb_move_to_data /etc/passwd
    wb_move_to_data /etc/shadow
    wb_move_to_data /etc/network/interfaces
    wb_move_to_data /etc/resolv.conf
    wb_move_to_data /etc/ssh
    wb_move_to_data /etc/dnsmasq.conf
    wb_move_to_data /etc/hostapd.conf
    wb_move_to_data /var/lib/wirenboard
    wb_move_to_data /var/lib/mosquitto
    wb_move_to_data nosave /var/cache/apt              # just fat, move it out
    wb_move_to_data nosave /var/www/uploads /uploads   # here will be firmware updates


    info "Restarting up network interface"
    if [ -e /etc/init.d/netplug ]; then
        /etc/init.d/netplug stop
    fi

    ifdown eth0 ; ifdown eth0 ; ifup eth0

    if [ -e /etc/init.d/netplug ]; then
        /etc/init.d/netplug start
    fi

    return 0
}

# TODO: Move all firstboot actions to rcS/99firstboot
# This will significantly speed-up initialization

[[ ! -e ${STORAGE}p3 ]] && wb_prepare_partitions

grep ${STORAGE}p6 /proc/mounts >/dev/null || wb_prepare_filesystems

FLAG="/var/lib/wirenboard/firstboot.flag"
if [ ! -f $FLAG ]; then
    wb_firstboot || die "Error in WB firstboot  script"

    touch $FLAG

    info "Rebooting..."
    reboot
    exit
fi

exit 0
